import reimport timeimport subprocessimport osimport keyboardimport datetimeimport socketleave = Falseimport warningswarnings.filterwarnings("ignore", category=RuntimeWarning)import threadingimport RPi.GPIO as GPIO#CHANGE THIS NUMBER IF DIFFRENT GPIO I USED FOR BUTTONSELECT_PIN = 3GPIO.setmode(GPIO.BCM)GPIO.setup(SELECT_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)seen_timestamps = set()with open('/var/log/auth.log', 'r') as auth_file:    with open('oldlogs.txt', 'a') as other_file:        other_file.write(auth_file.read())os.system('sudo cat /dev/null > /var/log/auth.log')print("\nLog attempts:\n")#most of the logging function will retrive useful logging data from their log file and clean it up to be presentable#telnet loggingdef telnet_log():    log_file = '/var/log/auth.log'    activity_logs_file = 'ActivityLogs.txt'    while True:        # Read the log file        with open(log_file, 'r') as f:            log_data = f.read()        # Extract xinetd connection info        pattern = r'START: telnet pid=\d+ from=::ffff:(\d+\.\d+\.\d+\.\d+)'        matches = re.findall(pattern, log_data)        if matches:            ip_address = matches[0]            timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())            print(f"Telnet: Timestamp: {timestamp} - IP: {ip_address}\n")            # Append to activity logs file            with open(activity_logs_file, 'a') as logs_file:                logs_file.write(f"Telnet: Timestamp: {timestamp} - IP: {ip_address}\n")        # Clear the log file            subprocess.check_call(['sudo', 'sh', '-c', f'echo "" > {log_file}'])        # Wait for 5 seconds before repeating        time.sleep(5)    #when select button is pressed. stops the logging and returns user to the menusdef select_button_handler(channel):    global leave    time.sleep(0.75)     leave = Truedef ftp_log():    with open('/var/log/vsftpd.log', 'r') as log_file:        log_file.seek(0, 2)  # Move to the end of the file        global leave        while not leave:            line = log_file.readline()            if not line:                time.sleep(0.1)                  continue            process_log_entry(line)#FTP LOGdef process_log_entry(line):    if 'FAIL LOGIN' in line:        timestamp = line.split('[', 1)[0].strip()        pid, client = line.split('[')[1].split(']')[0], line.split('] ')[1]        ip_address = re.search(r'Client "::ffff:(\d+\.\d+\.\d+\.\d+)"', line).group(1)        username = client.split(' ')[0]        username = username[1:]        print(f"FTP: Timestamp: {timestamp} - Username: {username} - IP address: {ip_address}")        with open('ActivityLogs.txt', 'a') as f:            f.write(f"FTP: Timestamp: {timestamp} - Username: {username} - IP address: {ip_address}\n")#SSH LOGdef ssh_log():    with open('/var/log/auth.log') as f:        global leave        while not leave:            line = f.readline()            if not line:                time.sleep(1)                continue            if 'Failed password' not in line:                continue            timestamp = re.search(r"^\w{3}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2}", line)            if timestamp is None:                continue            timestamp = timestamp.group(0)            if timestamp in seen_timestamps:                continue            seen_timestamps.add(timestamp)            result = re.search(r"Failed password for (.+) from (\d+\.\d+\.\d+\.\d+) port", line)            if result is None:                continue            username, ip_address = result.groups()            print(f"SSH: Timestamp: {timestamp} - Username: {username} - IP Address: ({ip_address})")            with open('ActivityLogs.txt', 'a') as d:               d.write(f"SSH: Timestamp: {timestamp} - Username: {username} - IP Address: ({ip_address})\n")#Low interaction http loggingdef lowhttp_log():    import time    OUTPUT_FILE = "ActivityLogs.txt"    LOG_FILE = "htmlpage/htmlLowlog.log"    global leave    while not leave:        with open(LOG_FILE, "r") as f, open(OUTPUT_FILE, "a") as out:            for line in f:                if "GET" in line:                    # Extract date, time, and IP address from log entry                    parts = line.split()                    date = parts[3][1:]                    times = parts[4][:-7]                    ip = parts[0]                    # Write extracted data to output file                    print(f"Http:  Date: {date}, Time: {times}, IP Address: {ip}\n")                    with open('ActivityLogs.txt', 'a') as f:                        f.write(f"Date: {date}, Time: {times}, IP Address: {ip}\n")        with open("htmlpage/htmlLowlog.log", "w") as file:            file.truncate(0)               time.sleep(5)#Medium interaction HTTP loggingdef medhttp_log():    # Open the input and output files    open('htmlpage/htmlMederror.log', 'a').close()    log_file = "htmlpage/htmlMederror.log"    global leave    while not leave:                # read the log file        with open(log_file, "r") as f:           log_lines = f.readlines()        # parse each log line        for line in log_lines:            match = re.search(r"\[(.*?)\].*?\[client (.*?):", line)            if match:                date_time = match.group(1)                ip_address = match.group(2)                # check if there is a username and password in the log line                user_match = re.search(r"username=(.*?)&password=(.*?)$", line)                if user_match:                    username = user_match.group(1)                     password = user_match.group(2)                    print(f"Http:  {date_time} {ip_address} {username} {password}\n")                    with open('ActivityLogs.txt', 'a') as f:                        f.write(f"{date_time} {ip_address} {username} {password}\n")                                        with open("htmlpage/htmlMederror.log", "w") as file:                        file.truncate(0)        # wait for a certain amount of time before checking for new entries        time.sleep(5)#Main functiondef run():    global leave    file_path = "chosenservices.txt"    #starts threads on the service funtions that is listed in the file    with open(file_path, "r") as file:        servicesArray = [service.strip() for service in file.readlines()]    for service in servicesArray:        if service == "22l":            ssht = threading.Thread(target=ssh_log)            ssht.start()        if service == "21l":            ftpt = threading.Thread(target=ftp_log)            ftpt.start()        if service == "23l":            telnett = threading.Thread(target=telnet_log)            telnett.start()        if service == "80l":            httptlowt = threading.Thread(target=lowhttp_log)            httptlowt.start()        if service == "80m":            httptmedt = threading.Thread(target=medhttp_log)            httptmedt.start()        if service == "23l":            pass   #joins threads    try:        while not leave:            pass    except KeyboardInterrupt:        try:            ssht.join()        except RuntimeError:             pass        try:            ftpt.join()        except RuntimeError:             pass        try:            httptlowt.join()        except RuntimeError:             pass        try:            icmp_listener_thread.join()        except RuntimeError:             pass        try:            httptmedt.join()        except RuntimeError:             pass        try:            telnett.join()        except RuntimeError:             pass                print("\nleaving...")#runs button in backgroundGPIO.add_event_detect(SELECT_PIN, GPIO.FALLING, callback=select_button_handler, bouncetime=200)#runs main functionrun()